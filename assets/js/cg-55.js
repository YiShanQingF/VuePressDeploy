(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{436:function(t,a,r){"use strict";r.r(a);var e=r(8),s=Object(e.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"juc并发编程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#juc并发编程"}},[t._v("#")]),t._v(" JUC并发编程")]),t._v(" "),a("blockquote",[a("p",[a("a",{attrs:{href:"https://www.bilibili.com/video/BV1Kw411Z7dF",target:"_blank",rel:"noopener noreferrer"}},[t._v("【尚硅谷】大厂必备技术之JUC并发编程 视频学习"),a("OutboundLink")],1)])]),t._v(" "),a("h2",{attrs:{id:"什么是-juc"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是-juc"}},[t._v("#")]),t._v(" 什么是 JUC")]),t._v(" "),a("blockquote",[a("p",[t._v("JUC就是 java.util .concurrent 工具包的简称。这是一个处理线程的工具包，JDK1.5 开始出现的。")])]),t._v(" "),a("h3",{attrs:{id:"进程与线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进程与线程"}},[t._v("#")]),t._v(" 进程与线程")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("进程（Process）")]),t._v(" 进程是正在运行的程序的实例。进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。")]),t._v(" "),a("li",[a("strong",[t._v("线程（thread）")]),t._v(" 是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。")])]),t._v(" "),a("blockquote",[a("p",[t._v("进程：指在系统中正在运行的一个应用程序；程序一旦运行就是进程；进程——资源分配的最小单位。")]),t._v(" "),a("p",[t._v("线程：系统分配处理器时间资源的基本单元，或者说进程之内独立执行的一个单元执行流。线程——程序执行的最小单位。")])]),t._v(" "),a("h3",{attrs:{id:"线程状态"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#线程状态"}},[t._v("#")]),t._v(" 线程状态")]),t._v(" "),a("p",[a("img",{staticClass:"lazy",attrs:{alt:"","data-src":"/images/java/juc/Java%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E6%B5%81%E8%BD%AC.png",loading:"lazy"}})]),t._v(" "),a("p",[a("strong",[t._v("wait/sleep 的区别")])]),t._v(" "),a("ul",[a("li",[t._v("sleep 是 Thread 的静态方法，wait 是 Object 的方法，任何对象实例都能调用。")]),t._v(" "),a("li",[t._v("sleep 不会释放锁，它也不需要占用锁。wait 会释放锁，但调用它的前提是当前线程占有锁(即代码要在 synchronized 中)。")]),t._v(" "),a("li",[t._v("它们都可以被 interrupted 方法中断。")])]),t._v(" "),a("h3",{attrs:{id:"并发与并行"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#并发与并行"}},[t._v("#")]),t._v(" 并发与并行")]),t._v(" "),a("ol",[a("li",[a("strong",[t._v("串行模式")]),t._v("串行是一次只能取得一个任务，并执行这个任务。")]),t._v(" "),a("li",[a("strong",[t._v("并行模式")]),t._v("同时取得多个任务，并同时去执行所取得的这些任务。")]),t._v(" "),a("li",[a("strong",[t._v("并发(concurrent)")]),t._v(" 指的是多个程序可以同时运行的现象，更细化的是多进程可以同时运行或者多指令可以同时运行。")])]),t._v(" "),a("blockquote",[a("p",[t._v("在描述并发的时候也不会去扣这种字眼是否精确，"),a("strong",[t._v("并发的重点在于它是一种现象")]),t._v(", "),a("strong",[t._v("并发描述的是多进程同时运行的现象")]),t._v('。但实际上，对于单核心 CPU 来说，同一时刻只能运行一个线程。所以，这里的"同时运行"表示的不是真的同一时刻有多个线程运行的现象，这是并行的概念，而是提供一种功能让用户看来多个程序同时运行起来了，但实际上这些程序中的进程不是一直霸占 CPU 的，而是执行一会停一会。')])]),t._v(" "),a("h3",{attrs:{id:"管程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#管程"}},[t._v("#")]),t._v(" 管程")]),t._v(" "),a("ul",[a("li",[t._v("管程(monitor)是保证了同一时刻只有一个进程在管程内活动,即管程内定义的操作在同一时刻只被一个进程调用(由编译器实现).但是这样并不能保证进程以设计的顺序执行")]),t._v(" "),a("li",[t._v("JVM 中同步是基于进入和退出管程(monitor)对象实现的，每个对象都会有一个管程(monitor)对象，管程(monitor)会随着 java 对象一同创建和销毁")]),t._v(" "),a("li",[t._v("执行线程首先要持有管程对象，然后才能执行方法，当方法完成之后会释放管程，方法在执行时候会持有管程，其他线程无法再获取同一个管程")])]),t._v(" "),a("h3",{attrs:{id:"用户线程和守护线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#用户线程和守护线程"}},[t._v("#")]),t._v(" 用户线程和守护线程")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("用户线程:")]),t._v(" 平时用到的普通线程,自定义线程")]),t._v(" "),a("li",[a("strong",[t._v("守护线程:")]),t._v(" 运行在后台,是一种特殊的线程,比如垃圾回收")]),t._v(" "),a("li",[a("strong",[t._v("当主线程结束后,用户线程还在运行,JVM 存活")])]),t._v(" "),a("li",[a("strong",[t._v("如果没有用户线程,都是守护线程,JVM 结束")])])]),t._v(" "),a("h2",{attrs:{id:"lock-接口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lock-接口"}},[t._v("#")]),t._v(" Lock 接口")]),t._v(" "),a("h3",{attrs:{id:"synchronized"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#synchronized"}},[t._v("#")]),t._v(" Synchronized")]),t._v(" "),a("h3",{attrs:{id:"什么是-lock"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是-lock"}},[t._v("#")]),t._v(" 什么是 Lock")]),t._v(" "),a("h3",{attrs:{id:"reentrantlock"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#reentrantlock"}},[t._v("#")]),t._v(" ReentrantLock")]),t._v(" "),a("h3",{attrs:{id:"readwritelock"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#readwritelock"}},[t._v("#")]),t._v(" ReadWriteLock")]),t._v(" "),a("h3",{attrs:{id:"小结-重点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#小结-重点"}},[t._v("#")]),t._v(" 小结(重点)")]),t._v(" "),a("h2",{attrs:{id:"线程间通信"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#线程间通信"}},[t._v("#")]),t._v(" 线程间通信")]),t._v(" "),a("h2",{attrs:{id:"集合的线程安全"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#集合的线程安全"}},[t._v("#")]),t._v(" 集合的线程安全")]),t._v(" "),a("h2",{attrs:{id:"多线程锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#多线程锁"}},[t._v("#")]),t._v(" 多线程锁")]),t._v(" "),a("h2",{attrs:{id:"callable-接口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#callable-接口"}},[t._v("#")]),t._v(" Callable 接口")]),t._v(" "),a("h2",{attrs:{id:"juc-三大辅助类-countdownlatch-cyclicbarrier-semaphore"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#juc-三大辅助类-countdownlatch-cyclicbarrier-semaphore"}},[t._v("#")]),t._v(" JUC 三大辅助类: CountDownLatch CyclicBarrier Semaphore")]),t._v(" "),a("h2",{attrs:{id:"读写锁-reentrantreadwritelock"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#读写锁-reentrantreadwritelock"}},[t._v("#")]),t._v(" 读写锁: ReentrantReadWriteLock")]),t._v(" "),a("h2",{attrs:{id:"阻塞队列"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#阻塞队列"}},[t._v("#")]),t._v(" 阻塞队列")]),t._v(" "),a("h2",{attrs:{id:"threadpool-线程池"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#threadpool-线程池"}},[t._v("#")]),t._v(" ThreadPool 线程池")]),t._v(" "),a("h2",{attrs:{id:"fork-join-框架"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#fork-join-框架"}},[t._v("#")]),t._v(" Fork/Join 框架")]),t._v(" "),a("h2",{attrs:{id:"completablefuture"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#completablefuture"}},[t._v("#")]),t._v(" CompletableFuture")])])}),[],!1,null,null,null);a.default=s.exports}}]);